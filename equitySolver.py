# equitySolver.py
# August 2022

# Given a CSV of values computed by calculateValues.py, this script finds a feasible transition
# scheme subject to parameters such as budget constraint, etc.  This script DOES consider
# the income group of each house (equity) when choosing neighborhoods to decommission.
# Returns the outcome of this experiment and plots a graph to the specified file.

# Original Paper Reference:
'''
Adam Lechowicz, Noman Bashir, John Wamburu, Mohammad Hajiesmaili, and Prashant Shenoy
Equitable Network-Aware Decarbonization of Residential Heating at City Scale
ACM International Conference on Future Energy Systems (e-Energy), 2023.
'''

import pandas as pd
import numpy as np
import sys
import math
import gasNet
import elecNet
import osmnx as ox
import networkx as nx
import pickle
import statistics

from dotenv import load_dotenv
load_dotenv()
import os
mainMapping = os.environ.get("mainMapping")
transFolder = os.environ.get("transformerDataFolder")
gasFolder = os.environ.get("gasDataFolder")
heatPumpCost = os.environ.get("heatPumpCost")
sourceNode = os.environ.get("sourceNode")

from time import time
from xml.dom import NotFoundErr
import geopandas as gpd
import pandas as pd
from shapely.geometry import Point
import matplotlib.pyplot as plt
import osmnx.geometries as gx
import numpy as np
import math
from sklearn.utils import shuffle

filename = sys.argv[1] # pass the name of CSV file generated by calculateValues.py (e.g. $ equitySolver.py results.csv)

# SET BUDGET FOR EXPERIMENT HERE (IN USD)
CONVERSION_BUDGET = 180000000

# set maintenance cost metric for full network
# (i.e. yearly maintenance cost for full city natural gas network is $9,000,000)
maintenanceCost = 9000000 

# filename for the image with mapped results
outputFilename = "graphEquityDecommissioned.png"

# knapsack of capacity W        -- W
# list of weights for each item -- weights
# list of values for each item  -- vals
# number of items               -- n
def dpOptimalKnapsack(W, weights, vals, n):
    dp = [0 for i in range(W + 1)]  # Making the dp array
    packed = set()

    if W < min(weights):
        return 0, set()

    for i in range(1, n + 1):  # taking first i elements
        sys.stdout.write('.')
        sys.stdout.flush()
        for w in range(W, 0, -1):  # starting from back,so that we also have data of
            # previous computation when taking i-1 items
            if weights[i - 1] <= w:
                if dp[w - weights[i - 1]] + vals[i - 1] > dp[w]:
                    packed.add(i-1)
                else:
                    if (i - 1) in packed:
                        packed.remove(i-1)
                dp[w] = max(dp[w], dp[w - weights[i - 1]] + vals[i - 1])

    return dp[W], packed  # returning the maximum value of knapsack, plus the packed values

# returns (kg, tons) of CO2 not emitted thanks to transition
# ccf represents natural gas usage in cubic feet.
def carbonReduction(ccf):
    return 5.51*ccf, 0.00551*ccf  

# gets the index of the next highest item in a list, given 
# a value that we need to accommodate
def getNextIndex(myList, load):
    ind = myList.index(min(myList, key=lambda x:abs(x-load)))
    if myList[ind] < load:
        ind += 1
    return ind

# computes the cost of converting houses from gas heating
# to ASHP, scaled based on median gas usage and median ASHP
# installation cost.
def getConversionCost(gn, gasPruned):
    usages = gn.usages
    median = statistics.median(gn.usages.values())
    totalPumps = 0
    for gasID in gasPruned: # for each converted house
        div = usages[int(gasID)] / median
        totalPumps += div
    return heatPumpCost * totalPumps

# computes the cost of upgrading newly overloaded transformers
# due to ASHP installations
def getOverloadCost(en, upgradedTrans):
    upgradedtIDs = upgradedTrans.keys()
    capacities = [15, 25, 37.5, 50, 75, 100, 150, 167, 225]
    cost = 0.0
    for tID in upgradedtIDs: # for each transformer to be upgraded
        existingkVA = en.transformers[tID]['kVA']
        peakLoad = upgradedTrans[tID]
        requiredkVA = peakLoad/0.95 # compute the absolute minimum required kVA rating

        if requiredkVA < existingkVA*2 and existingkVA < 75: # next-nearest pole-top upgrade
            base = 10225.0
            delta = 21300.0
            delScale = (getNextIndex(capacities, requiredkVA)/4.0)
            cost += (base + delScale*delta)
        elif requiredkVA > existingkVA*3 and existingkVA < 75: #pole-top to pad-mount conversion
            base = 79050.0
            delta = 74900.0
            delScale = (getNextIndex(capacities, requiredkVA)-4)/4.0
            cost += (base + delScale*delta)
        elif requiredkVA > existingkVA*2 and existingkVA < 75: #additional pole-top
            base = 10225.0
            delta = 21300.0
            addkVA = requiredkVA - existingkVA
            delScale = (getNextIndex(capacities, addkVA)/4.0)
            cost += (base + delScale*delta)
        elif requiredkVA > existingkVA*2 and existingkVA > 75: #additional pad-mount
            base = 74900.0
            delta = 74900.0
            addkVA = requiredkVA - existingkVA
            delScale = (getNextIndex(capacities, addkVA)-4)/4.0
            cost += (base + delScale*delta)
    return cost

# given a list of houses where gas service has been shut off,
# computes the distribution of income tracts that these houses represent.
def getGroupDistribution(incomeMap, gasPruned):
    groups = {1: 0, 2: 0, 3: 0}
    total = len(gasPruned)
    if total < 1:
        return np.array([0.0,0.0,0.0])
    for gasID in gasPruned:
        groups[incomeMap[int(gasID)]] += 1.0
    return np.array([groups[1]/total, groups[2]/total, groups[3]/total])

budget = int(CONVERSION_BUDGET/10)
# create an equal distribution of budgets across all income groups (this can be changed)
runningBudget = [int((CONVERSION_BUDGET/3)/10), int((CONVERSION_BUDGET/3)/10), int((CONVERSION_BUDGET/3)/10)]

try:
    df = pd.read_csv(filename)
    df= df[df['total_cost'] > 0]
except FileNotFoundError:
    print("{} not found!".format(filename))

# we want to maximize value (carbon reduction) w.r.t. costs
carbonReduced = list(df['carbon_reduced'])
totalCosts = list(df['total_cost'])

# scale costs by a factor of 10 to improve runtime
totalCostsR = [x/10 for x in totalCosts]

# cast to integers to use DP knapsack algorithm
values = [math.ceil(x) for x in carbonReduced]
weightsQ = [math.ceil(x) for x in totalCostsR]

# load mapping from a given house to each respective income group.
incomeMapping = pickle.load( open( "incomeMapping.pickle", "rb" ) )

# compute knapsack for the given list of items
result = dpOptimalKnapsack(budget, weightsQ, values, len(values))
edgeIndices = result[1]

# initialize gasNet and elecNet
gn = gasNet.GasNet()
en = elecNet.ElecNet()

# save parameters for evaluation
totalSavedCCF = 0
addedOverload = 0
totalHousesPruned = []
original_length = gn.totalNetworkLength()
original_edges = gn.G.number_of_edges()
done = False
looped = (0,0)

while not done:
    edges_u = list(df['edge_u'])
    edges_v = list(df['edge_v'])
    indexList = list(df.index)

    # for each edge which is to be deleted
    for index in edgeIndices:
        # computes cost with respect to the investment in each income tract
        cost = np.array([0.0,0.0,0.0])
        orig_overloaded, orig_overload_percentage = en.overloadingFactor(en.baseLoad)
        oldG = gn.G.copy()
        oldLoad = en.baseLoad.copy()
        
        u = edges_u[index]
        v = edges_v[index]

        print("Pruning Edge ({}, {})...".format(u,v))
        # check whether the edge we are trying to delete still exists
        if not gn.G.has_edge(u,v,0) and not gn.G.has_edge(u,v,1):
            # EDGE MISSING!!!
            print("edge missing. current budget: {}".format(runningBudget))
            df = df[(df['edge_u'] != u) & (df['edge_v'] != v)] # drop this row since the edge is already gone
            break
        
        # delete the edge
        (gasPruned, lengthPruned), elecDict = gn.pruneEdge(u, v, 0, save=True)
        df = df[(df['edge_u'] != u) & (df['edge_v'] != v)] # drop this row since the edge is already gone

        # calculate the income tracts of the houses which are proposed for transition
        incomeDist = getGroupDistribution(incomeMapping, gasPruned)
        conCost = getConversionCost(gn, gasPruned)
        cost = cost + (incomeDist * conCost) # gives the conversion cost for each income tract
        
        # calculate outcome of this edge deletion (for more details see comments in calculateValues.py)
        newLoad, savedCCF = en.addLegacyGasLoad(elecDict)

        newLength = original_length - lengthPruned
        y = (newLength * maintenanceCost) / (original_length)
        savings = maintenanceCost - y
        cost = cost - (incomeDist * savings)

        new_overloaded, percentage = en.overloadingFactor(newLoad)
        upgradedTrans = {}
        for key in new_overloaded.keys():
            if key not in orig_overloaded.keys():
                upgradedTrans[key] = new_overloaded[key]

        overloadCost = getOverloadCost(en, upgradedTrans)
        cost = cost + (incomeDist * overloadCost) # gives the conversion cost for each income tract

        # need to compute the cost and compare against budget for each of the three income groups
        OVERRUN = False 
        newBudget = [0.0, 0.0, 0.0]
        for i, value in enumerate(cost):
            val = math.ceil(value/10) # adjust for knapsack
            if val > runningBudget[i]:
                OVERRUN = True
                break
            newBudget[i] = runningBudget[i] - val

        if OVERRUN: # if the budget has been exceeded for any group, this option is infeasible
            # roll back
            gn.G = oldG
            if looped == (edges_u, edges_v):
                print("stuck in a loop")
                break
            looped = (edges_u, edges_v)
            continue

        # otherwise, add this neighborhood to the set of pruned houses, and prepare to delete the next edge.
        totalSavedCCF += savedCCF
        totalHousesPruned.extend(gasPruned)
        en.setNewLoad(newLoad)
        addedOverload += len(new_overloaded.keys()) - len(orig_overloaded.keys())
            
        runningBudget = newBudget
        print(runningBudget)

    # check whether we should terminate.
    if not done:
        # if any group's remaining budget is smaller than the cost of any options, we are done.
        if max(runningBudget) < min(weightsQ):
            done = True
            continue
        
        # clean edges from the list of options if they no longer exist
        for i in edgeIndices:
            u = edges_u[i]
            v = edges_v[i]
            if (u,v) == looped:
                df = df[(df['edge_u'] != u) & (df['edge_v'] != v)] # drop this row since it causes problems
            if not gn.G.has_edge(u,v,0) and not gn.G.has_edge(u,v,1):
                df = df[(df['edge_u'] != u) & (df['edge_v'] != v)] # drop this row since it no longer exists
        
        # we want to maximize value (carbon reduction) w.r.t. costs
        carbonReduced = list(df['carbon_reduced'])
        totalCosts = list(df['total_cost'])

        # scale costs by a factor of 10 to improve runtime
        totalCostsR = [x/10 for x in totalCosts]

        # cast to integers to use DP knapsack algorithm
        values = [math.ceil(x) for x in carbonReduced]
        weightsQ = [math.ceil(x) for x in totalCostsR]

        # compute knapsack for the given list of items
        result = dpOptimalKnapsack(sum(runningBudget), weightsQ, values, len(values))
        edgeIndices = result[1]
        # if we are not done, this goes back and continues deleting edges

# calculate final results - # of edges deleted, length deleted, carbon reduced...
newEdges = gn.G.number_of_edges()
newLength = gn.totalNetworkLength()
carbonReduced = carbonReduction(totalSavedCCF)[0]

totalCost = budget - sum(runningBudget)

totalUtility = carbonReduced/totalCost

# print results to the console
print("Total Cost: {}".format(totalCost))
print("Carbon Reduced: {}".format(carbonReduced))
print("Overloaded Transformers: {}".format(addedOverload))
print("Households Converted: {}".format(len(totalHousesPruned)))
print("Edges Deleted: {}".format(original_edges-newEdges))
print("Length Deleted: {}".format(original_length-newLength))

# based on the OSM graph, plot the decommissioned portions of the gas network.
# deleted edges are in RED, and extant edges are GRAY.
print("Plotting...")
nn = gasNet.GasNet()

# choose color based on whether the edge exists in the experimental graph.
colorDict = {}
edgeList = list(nn.G.edges)
for u,v,e in nn.G.edges:
    if not gn.G.has_edge(u,v,e):
        colorDict[(u,v,e)] = "#FF0001"
    else:
        colorDict[(u,v,e)] = "#444444"

ser = pd.Series(data=colorDict, index=edgeList)

# here we make a new node for each house disconnected from gas (just for visualization's sake)
pointsList = []
groups = []
df = pd.read_csv(mainMapping)

# classify each house based on income tract
for meterID, lat, long in zip(df["gas_meter_id"], df["lat"], df["long"]):
    if meterID in totalHousesPruned:
        pointsList.append(Point(long, lat))
        groups.append(incomeMapping[meterID])

# convert to GeoSeries (enables next step)
points = gpd.GeoSeries(pointsList, crs='epsg:4326')

# project to CRS (coordinate reference system) used by the projected graph (this is for accuracy)
pointsProg = points.to_crs(nn.G.graph['crs'])
        
# plots the main map graph of the gas network
fig, ax = ox.plot_graph(
    nn.G, bgcolor="w", node_color="#444444", figsize=(30, 15), node_size=5, edge_linewidth=2, edge_color=ser, show=False, save=False, close=False
)

# adds "points" representing each house's income tract & location to the map graph plotted above.
houseAlpha = 0.5
houseSize = 25
for i, (point, group) in enumerate(zip(pointsProg, groups)):
    if group == 1:
        ax.scatter(point.x, point.y, c="#0173B2", s = houseSize, alpha = houseAlpha)
    elif group == 2:
        ax.scatter(point.x, point.y, c="#029E73", s = houseSize, alpha = houseAlpha)
    elif group == 3:
        ax.scatter(point.x, point.y, c="#D55E00", s = houseSize, alpha = houseAlpha)
    else:
        ax.scatter(point.x, point.y, c="#222222", s = houseSize, alpha = houseAlpha)

extent = ax.bbox.transformed(fig.dpi_scale_trans.inverted())
plt.draw()
plt.savefig(outputFilename, bbox_inches=extent, dpi=200)

